package main

import (
	"fmt"
)

func main() {
	// Functions
	fmt.Println("Functions:")

	for i := 0; i < 5; i++ {
		sayMessage("Za Warudo!", i)
	}

	// Anonymous function
	func() {
		fmt.Println("Anon")
	}() // immediately invoked after definition to pass the compilation check of defined must be used

	// Anonymous function used asynchronously
	for i := 0; i < 5; i++ {
		// this anon function have access to outer scope variable
		// if this function is running asynchronously, i won't be printed in order
		// func() {
		// 	fmt.Println(i)
		// }

		// Best practice: declare param and pass in the arg
		// changes on the outer scope won't reflect on the inner scope
		// will run in order despite async
		func(i int) {
			fmt.Println(i)
		}(i)
	}

	// saving anon function to variable
	// if the function is declared as a variable, function call must be made below the definition
	var f func() = func() { // can also be declared f := func() {}
		fmt.Println("Anon f function")
	}
	// called after
	f()

	// passing in by Value
	greeting := "Moshi Moshi"
	name := "Jake"
	sayGreetings(greeting, name)
	fmt.Println(name)

	// passing in by Pointer
	sayGreetingsPointer(&greeting, &name) // passing in address to those variables
	fmt.Println(name)

	// Variadic parameters
	sumPrint("The sum is", 1, 2, 3, 4, 5)

	// Return value
	fmt.Println("The sum is", sumReturn(1, 2, 3, 4, 5))
	// Return pointer value
	fmt.Println("The sum is", sumReturnPointer(1, 2, 3, 4, 5))
	// Named return value
	fmt.Println("The sum is", sumNamedReturn(1, 2, 3, 4, 5))
	// Multiple return value
	d, err := divide(5.0, 3.0)
	// common error handling
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(d)

	// Methods
	fmt.Println("Methods:")

	g := greeter{
		greeting: "Hello",
		name:     "Go",
	}
	// calling a method
	g.greet()
	// call that mutates
	g.pointerGreet()
	fmt.Println("The new name now is:", g.name)

}

// func functionName(paramName paramType, param2 type2, and so on) {}
func sayMessage(msg string, idx int) {
	fmt.Println(msg)
	fmt.Println("The value of the index is", idx)
}

// when having multiple params of the same type, group them together and put the type in the end
func sayGreetings(greeting, name string) {
	fmt.Println(greeting, name)
	name = "Ted" // name in here is a copy of the value
	// changiing the name in this scope does not change the name value outside
	fmt.Println(name)
}

// param now takes pointers of string args
func sayGreetingsPointer(greeting, name *string) {
	fmt.Println(*greeting, *name) // dereference args
	*name = "Ted"                 // dereference name here, changing the value in the memory address
	fmt.Println(*name)
	// name value is changed in the outer scope too
}

// Variadic parameter: like rest parameter or spread operator
// takes in an unknown number of arguments of int and wrap them up in a slice called values
// can only have one variadic parameter, and have to be at the end
func sumPrint(msg string, values ...int) {
	fmt.Println(values)
	result := 0
	for _, v := range values {
		result += v
	}
	fmt.Println(msg, result)
}

// function return value
// func funcName(param paramType) return Type {}
func sumReturn(values ...int) int {
	fmt.Println(values)
	result := 0
	for _, v := range values {
		result += v
	}
	return result // return value that's used in the outer scope is a copy of this local variable result
}

// returning a local variable as a pointer
func sumReturnPointer(values ...int) *int {
	fmt.Println(values)
	result := 0
	for _, v := range values {
		result += v
	}
	return &result // return address of this local variable
}

// named return value
// syntactic sugar for declaring a result variable to be returned
func sumNamedReturn(values ...int) (result int) {
	fmt.Println(values)
	for _, v := range values {
		result += v
	}
	// return variable is implicitly returned
	return
}

// error handling returns, instead of using panic
// adding a second return variable
func divide(a, b float64) (float64, error) {
	// doing error checking in the beginning
	if b == 0.0 {
		// return something meaningless, then return a error object generated by Errorf function
		// must return 2 values here cuz of the declared second return variable
		return 0.0, fmt.Errorf("cannot divide by zero")
	}
	return a / b, nil // must return 2 values
}

type greeter struct {
	greeting string
	name     string
}

// Method declaration
// Method is basically a function that's executing in a known context (any type)
// when called, this greet method will get a copy of the greeter object given the name g in this context
// greeter here declared as a value type (not a pointer): value receiver
func (g greeter) greet() {
	// here it's operating on a copy
	fmt.Println(g.greeting, g.name)
}

// pointer receiver
func (g *greeter) pointerGreet() {
	fmt.Println(g.greeting, g.name)
	// now we can manipulate original greeter object
	// implicit dereferencing of struct
	g.name = "Goo"
}
